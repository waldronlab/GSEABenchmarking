---
title: "Analysis vignette for GSEA Benchmarking manuscript"
author: Ludwig Geistlinger
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  % \VignetteIndexEntry{GSEA Benchmarking manuscript analysis}
  % \VignetteEngine{knitr::rmarkdown}
---

```{r style, echo = FALSE}
suppressPackageStartupMessages({ 
    library(GSEABenchmarkeR)
    library(EnrichmentBrowser)
    library(ggpubr)
    library(ComplexHeatmap)
})
```

# Setup
```{r setup}
library(EnrichmentBrowser)
library(GSEABenchmarkeR)
cb.pink <- "#CC79A7"
cb.darkred <- "#B42F32"
cb.red <- "#D55E00"
cb.lightred <- "#DF6747"
cb.blue <- "#0072B2"
cb.yellow <- "#F0E442"
cb.green <- "#009E73"
cb.lightblue <- "#56B4E9"
cb.lightorange <- "#FAAC77"
cb.orange <- "#E69F00"
cb.darkorange <- "#F6893D"
cb.lightgrey <- "#C9C9BD"
cb.darkgrey <- "#878D92"
```

# Expression data sources

## Microarray compendium
```{r maComp}
data.dir <- "data"
ma.dir <- file.path(data.dir, "GEO2KEGG_preproc")
geo2kegg <- loadEData(ma.dir)
ma.ids <- names(geo2kegg)
ma.ids
```

## RNA-seq compendium
```{r rseqComp}
rseq.dir <- file.path(data.dir, "TCGA_preproc")
rseq.raw <- file.path(rseq.dir, "GSE62944_matched_limmavoom")
rseq.vst <- file.path(rseq.dir, "GSE62944_matched_vst")
rseq.tpm <- file.path(rseq.dir, "cTD_matched_tpm")
tcga.raw <- loadEData(rseq.raw)
tcga.vst <- loadEData(rseq.vst)
tcga.tpm <- loadEData(rseq.tpm)
rseq.ids <- names(tcga.raw)
rseq.ids
```

### DE distribution
```{r deComp}
geo2kegg <- runDE(geo2kegg, padj.method="BH")
bh.padj <- function(se)
{
    rowData(se)$ADJ.PVAL <- p.adjust(rowData(se)$PVAL, method="BH")
    return(se)
}
tcga.raw <- lapply(tcga.raw, bh.padj)
tcga.vst <- lapply(tcga.vst, bh.padj)
plotDEDistribution(geo2kegg)
plotDEDistribution(tcga.raw)
plotDEDistribution(tcga.vst)
```

Comparison of DE results for different RNA-seq approaches:
- raw read counts + voom/limma
- vst counts + limma
- log2 TPMs + limma

```{r corsDE}
# VST
cors.vst <- vapply(rseq.ids, 
    function(id) 
        cor(rowData(tcga.raw[[id]])$FC, 
            rowData(tcga.vst[[id]])$FC), 
    numeric(1))
sort(round(cors.vst, digits=3))
corsp.vst <- vapply(rseq.ids, 
    function(id) 
        cor(-log(rowData(tcga.raw[[id]])$PVAL, base=10), 
            -log(rowData(tcga.vst[[id]])$PVAL, base=10)), 
    numeric(1))
sort(round(corsp.vst, digits=3))

# TPM
cors.tpm <- vapply(names(tcga.tpm), 
    function(id) 
        cor(rowData(tcga.tpm[[id]])$FC, 
            rowData(tcga.raw[[id]][names(tcga.tpm[[id]]),])$FC), 
    numeric(1))
sort(round(cors.tpm, digits=3))

corsp.tpm <- vapply(names(tcga.tpm), 
    function(id) 
        cor(-log(rowData(tcga.tpm[[id]])$PVAL, base=10), 
            -log(rowData(tcga.raw[[id]][names(tcga.tpm[[id]]),])$PVAL, base=10)), 
    numeric(1))
sort(round(corsp.tpm, digits=3))

# log TPM
tcga.logtpm <- lapply(tcga.tpm, 
    function(se)
    { 
        assay(se) <- log(assay(se) + 1, base=2)
        return(se)
    })
tcga.logtpm <- runDE(tcga.logtpm)

cors.logtpm <- vapply(names(tcga.logtpm), 
    function(id) 
        cor(rowData(tcga.logtpm[[id]])$FC, 
            rowData(tcga.raw[[id]][names(tcga.logtpm[[id]]),])$FC), 
    numeric(1))
sort(round(cors.logtpm, digits=3))

corsp.logtpm <- vapply(names(tcga.logtpm), 
    function(id) 
        cor(-log(rowData(tcga.logtpm[[id]])$PVAL, base=10), 
            -log(rowData(tcga.raw[[id]][names(tcga.logtpm[[id]]),])$PVAL, base=10)), 
    numeric(1))
sort(round(corsp.logtpm, digits=3))

# overall
fc.mat <- data.frame(cors.vst, cors.tpm[rseq.ids], cors.logtpm[rseq.ids])
round(fc.mat, digits=3)
p.mat <- data.frame(corsp.vst, corsp.tpm[rseq.ids], corsp.logtpm[rseq.ids])
round(p.mat, digits=3)
```

## Golub

Frequently used data set, one of the first to use microarray data in a 
classification context.
[Golub et al. (1999)](https://www.ncbi.nlm.nih.gov/pubmed/10521349)

```{r golub}
library(golubEsets)
library(vsn)

data(Golub_Train)
exprs(Golub_Train) <- exprs(vsn2(Golub_Train))

se <- probe2gene(Golub_Train)
se$GROUP <- ifelse(se$ALL.AML == "ALL", 1, 0)
se <- deAna(se)
se
```

# Gene sets

## KEGG
```{r keggGS}
kegg.gs <- getGenesets(org="hsa", db="kegg")
length(kegg.gs)
(min.size <- EnrichmentBrowser::configEBrowser("GS.MIN.SIZE"))
(max.size <- EnrichmentBrowser::configEBrowser("GS.MAX.SIZE"))
ind <- (lengths(kegg.gs) >= min.size) & (lengths(kegg.gs) <= max.size)
kegg.gs <- kegg.gs[ind]
length(kegg.gs)
MASS::truehist(lengths(kegg.gs), nbins=50) 
```

## GO
```{r goGS}
go.gs <- getGenesets(org="hsa", db="go", go.onto="BP")
length(go.gs)
ind <- (lengths(go.gs) >= min.size) & (lengths(go.gs) <= max.size)
go.gs <- go.gs[ind]
length(go.gs)
MASS::truehist(lengths(go.gs), nbins=50)
```

# Benchmarking

```{r resDir}
res.dir <- file.path(data.dir, "results")
geo.dir <- file.path(res.dir, "GEO2KEGG")
```

## Runtime
```{r keggRT}
ea.methods <- sbeaMethods()[1:10]
kegg.dir <- file.path(geo.dir, "kegg/perm1k")
ma.kegg.rtimes <- readResults(kegg.dir, ma.ids, 
                                methods=ea.methods, type="runtime")
lengths(ma.kegg.rtimes)
ma.kegg.rtimes[1:2]
```

```{r goRT}
go.dir <- file.path(geo.dir, "go_bp")
ma.go.rtimes <- readResults(go.dir, ma.ids, 
                                methods=ea.methods, type="runtime")
lengths(ma.go.rtimes)
```

```{r plotKEGGRuntime}
bpPlot(ma.kegg.rtimes, what="runtime")
```
```{r plotGORuntime}
bpPlot(ma.go.rtimes, what="runtime")
```

Using ggpubr / ggplot2:
```{r plotKEGGRuntime2}
library(ggpubr)
plotRuntime2 <- function(rtimes)
{
    x <- do.call(cbind, rtimes)
    df <- reshape2::melt(x)
    df$value <- log(df$value, base=10)
    df$Var2 <- substring(df$Var2, 1, 7)
    medians <- vapply(rtimes, median, numeric(1))
    o <- names(sort(medians))
    o <- substring(o, 1, 7)
    p <- ggboxplot(df, x = "Var2", y = "value", width = 0.8, 
        ylab="log10 runtime [sec]", xlab="", order=o, fill="Var2")
    p <- ggpar(p, x.text.angle=45, palette = "simpsons", legend="none") + 
        grids("y", linetype = "dashed")
    return(p)
}
p <- plotRuntime2(ma.kegg.rtimes) 
p + geom_label(x=10, y=0, label="1 sec", col="grey") + 
geom_label(x=1.5, y=1, label="10 sec", col="grey") + 
geom_label(x=1.5, y=2, label="1 min 40 sec", col="grey") 
```


```{r plotGORuntime2}
p <- plotRuntime2(ma.go.rtimes)
p + geom_label(x=10, y=1, label="10 sec", col="grey") +
geom_label(x=1.5, y=2, label="1 min 40 sec", col="grey") + 
geom_label(x=1.5, y=3, label="15 min 40 sec", col="grey")
```

```{r rseqRuntime}
tcga.dir <- file.path(res.dir, "TCGA")
vst.dir <- file.path(tcga.dir, "GSE62944_matched_vst")
rseq.kegg.dir <- file.path(vst.dir, "kegg")
rseq.go.dir <- file.path(vst.dir, "gobp")
rseq.kegg.rtimes <- readResults(rseq.kegg.dir, rseq.ids, 
                                    methods=ea.methods, type="runtime")
rseq.go.rtimes <- readResults(rseq.go.dir, rseq.ids, 
                                    methods=ea.methods, type="runtime")
bpPlot(rseq.kegg.rtimes, what="runtime")
bpPlot(rseq.go.rtimes, what="runtime")
```

```{r facetplot}
facetplot <- function(ma.kegg, ma.go, rseq.kegg, rseq.go, 
    ylab="% significant sets", vline=6.5, log=FALSE)
{
    l <- list(ma.kegg=ma.kegg, ma.go=ma.go, rseq.kegg=rseq.kegg, rseq.go=rseq.go)
    df <- reshape2::melt(l)
    gsc <- vapply(df$L1, function(x) unlist(strsplit(x,"\\."))[2], 
                    character(1), USE.NAMES=FALSE)
    df <- cbind(df, gsc=gsc)
    df$gsc <- toupper(df$gsc)
    df$gsc <- vapply(df$gsc, function(n) 
                ifelse(n == "GO", paste(n, "BP", sep="-"), n), 
                character(1), USE.NAMES=FALSE)
    df$gsc <- factor(df$gsc, levels=c("KEGG", "GO-BP"))
    colnames(df)[1:2] <- c("dataset", "method")
    colnames(df)[4] <- "compendium"
    df$compendium <- sub("ma.kegg", "GEO2KEGG microarray", df$compendium)
    df$compendium <- sub("rseq.go", "TCGA RNA-seq", df$compendium)
    df$compendium <- sub("rseq.kegg", "TCGA RNA-seq", df$compendium)
    df$compendium <- sub("ma.go", "GEO2KEGG microarray", df$compendium)
    df$method <- substring(df$method, 1, 7)
    if(log) df$value <- log(df$value, base=10)
    o <- sort(vapply(split(df$value, df$method), 
                        median, numeric(1), na.rm=TRUE))
    df$method <- factor(df$method, levels=names(o))
    p <- ggboxplot(df, x = "method", y = "value", 
        width = 0.8, ylab=ylab, xlab="", fill="method")
    p <- ggpar(p, x.text.angle=45, palette = "simpsons", legend="none") 
    if(!is.na(vline)) 
        p <- p + geom_vline(xintercept=vline, linetype="dashed", color = cb.darkgrey)
    p <- facet(p, facet.by=c("compendium", "gsc"))     
    return(p)
}    
```

```{r facetRuntime}
p <- facetplot(do.call(cbind, ma.kegg.rtimes), 
            do.call(cbind, ma.go.rtimes), 
            do.call(cbind, rseq.kegg.rtimes), 
            do.call(cbind, rseq.go.rtimes),
            ylab="log10 runtime [sec]",
            vline=NA, log=TRUE)
p + grids("y", linetype = "dashed") +
geom_label(x=9, y=0, label="1 sec", col="grey", size=2.5) +
geom_label(x=9, y=1, label="10 sec", col="grey", size=2.5) +
geom_label(x=2, y=2, label="1 min 40 sec", col="grey", size=2.5) +
geom_label(x=2, y=3, label="15 min 40 sec", col="grey", size=2.5)
```

Checking different RNA-seq modes (raw vs. vst):
```{r rseqModesRuntime}
raw.dir <- file.path(tcga.dir, "GSE62944_matched_limmavoom")
raw.kegg.dir <- file.path(raw.dir, "kegg")
raw.kegg.rtimes <- readResults(raw.kegg.dir, rseq.ids, 
                                methods=list.files(raw.kegg.dir), type="runtime")
rtimes <- c(raw.kegg.rtimes[c("camera", "gsva", "roast")], 
            rseq.kegg.rtimes[c(c("camera", "gsva", "roast"))])
names(rtimes) <- paste(names(rtimes), c(rep("raw",3), rep("vst", 3)), sep=".")
rtimes <- rtimes[c(4,1,6,3,5,2)]
rtimes <- lapply(rtimes, log, base = 10)
ylab <- "log10 runtime [sec]"
par(las = 2)
boxplot(rtimes, col = rep(rainbow(3), each=2), ylab = ylab)
```

```{r safeRseqModesRuntime}
safe.kegg.rtimes <- list(vst=rseq.kegg.rtimes$safe, raw=raw.kegg.rtimes$safe)
bpPlot(safe.kegg.rtimes, what="runtime")
```

### Conclusion

Median runtime:

- KEGG: min: camera (0.25 *sec*); max: gsea (1.43 *min*)
- GO: min: camera(7.7 *sec*); max: gsea (35.1 *min*) 

Three groups:

1. simple tests: camera, globaltest, ora, mgsa
2. light permutation: gsva, safe, roast, ebm, samgs
3. heavy permutation: gsa, padog, gsea

## Statistical significance 

```{r readRankings}
ma.kegg.ranks <- readResults(kegg.dir, ma.ids, 
                                methods=ea.methods, type="ranking")
ma.go.ranks <- readResults(go.dir, ma.ids,
                                methods=ea.methods, type="ranking")
lengths(ma.kegg.ranks)
ma.kegg.ranks$ora[1:2]
```

### Nominal *p*-values

```{r plotSigSetsKEGG}
ma.kegg.sig.sets <- evalNrSigSets(ma.kegg.ranks, alpha=0.05, padj="none")
bpPlot(ma.kegg.sig.sets, what="sig.sets")
```
```{r plotSigSetsGO}
ma.go.sig.sets <- evalNrSigSets(ma.go.ranks, alpha=0.05, padj="none")
bpPlot(ma.go.sig.sets, what="sig.sets")
```

```{r rseqSigSets}
rseq.kegg.ranks <- readResults(rseq.kegg.dir, rseq.ids, 
                                methods=ea.methods, type="ranking")
rseq.kegg.sig.sets <- evalNrSigSets(rseq.kegg.ranks, alpha=0.05, padj="none")
rseq.go.ranks <- readResults(rseq.go.dir, rseq.ids, 
                                methods=ea.methods, type="ranking")
rseq.go.sig.sets <- evalNrSigSets(rseq.go.ranks, alpha=0.05, padj="none")

facetplot(ma.kegg.sig.sets, ma.go.sig.sets, rseq.kegg.sig.sets, rseq.go.sig.sets)
```

### Random gene sets of increasing size using true sample labels

```{r rand-dir}
golub.dir <- file.path(res.dir, "golub")
random.dir <- file.path(golub.dir, "randomGS", "true_labels")
gs.grid <- c(5, 10, 25, 50, 100, 250, 500)
gs.grid <- paste0("gs", gs.grid)
```

```{r randGSTrue}
ea.random <- readResults(random.dir, gs.grid, 
                            methods=ea.methods, type="ranking")
sig.sets <- evalNrSigSets(ea.random, alpha=0.05, padj="none")
ind <- order( apply(sig.sets, 2, median) )
sig.sets <- sig.sets[, ind]
round(sig.sets, digits=1)
GSEABenchmarkeR:::plotGSSizeRobustness(sig.sets, what="sig.sets")
```


```{r randGSTrue2}
df <- reshape2::melt(sig.sets)
colnames(df) <- c("Size", "Method", "value")
df$Method <- substring(df$Method, 1, 7)
df$Method <- factor(df$Method, levels=substring(rev(colnames(sig.sets)),1,7))
df$Size <- sub("^gs", "", df$Size)
col <- rev(get_palette(palette = "simpsons", 10))
p <- ggline(df, x = "Size", y = "value", linetype = "Method", color="Method",
    palette = "simpsons", ylab="% significant sets", xlab="gene set size") +
geom_hline(yintercept=5, linetype="dashed", color = cb.darkgrey) 
p
```

### Adjusted *p*-values
```{r plotAdjSigSetsKEGG}
ma.kegg.sig.sets <- evalNrSigSets(ma.kegg.ranks, alpha=0.05, padj="BH")
bpPlot(ma.kegg.sig.sets, what="sig.sets")
```
```{r plotAdjSigSetsGO}
ma.go.sig.sets <- evalNrSigSets(ma.go.ranks, alpha=0.05, padj="BH")
bpPlot(ma.go.sig.sets, what="sig.sets")
```

```{r rseqSigSetsBH}
rseq.kegg.sig.sets <- evalNrSigSets(rseq.kegg.ranks, alpha=0.05, padj="BH")
rseq.go.sig.sets <- evalNrSigSets(rseq.go.ranks, alpha=0.05, padj="BH")
facetplot(ma.kegg.sig.sets, ma.go.sig.sets, rseq.kegg.sig.sets, rseq.go.sig.sets)
```

### Use built-in FDR-control for GSEA and SAFE
```{r builtInFDR}
fdr.dir <- file.path(kegg.dir, "builtInFDR")
fdr.methods <- c("gsea", "safe") 
ea.kegg.ranks.fdr <- readResults(fdr.dir, ma.ids, 
                                    methods=fdr.methods, type="ranking")
sig.sets <- evalNrSigSets(ea.kegg.ranks.fdr)
bpPlot(sig.sets, what="sig.sets")
```

### Number of permutations (1k -> 10k)
```{r plotSigSetsKEGG100k}
kegg.dir <- sub("1k$", "10k", kegg.dir)
perm.methods <- c("gsa", "gsea", "padog", "roast", "safe", "samgs")
ea.kegg.ranks.10k <- readResults(kegg.dir, ma.ids, 
                                    methods=perm.methods, type="ranking")
sig.sets <- evalNrSigSets(ea.kegg.ranks.10k, alpha=0.05, padj="BH")
bpPlot(sig.sets, what="sig.sets")
```

```{r builtInFDR10k}
fdr.dir <- file.path(kegg.dir, "builtInFDR")
ea.kegg.ranks.fdr.10k <- readResults(fdr.dir, ma.ids, 
                                        methods=fdr.methods, type="ranking")
sig.sets <- evalNrSigSets(ea.kegg.ranks.fdr.10k)
bpPlot(sig.sets, what="sig.sets")
```

### Correlation with DE
```{r corDE}
ma.de <- vapply(geo2kegg, function(se) GSEABenchmarkeR:::.fractDE(se), numeric(2))
ma.de <- ma.de["p",]
rseq.de <- vapply(tcga.raw, function(se) GSEABenchmarkeR:::.fractDE(se), numeric(2))
rseq.de <- rseq.de["p",]
plotCorDE <- function(de, sig.sets)
{
    cors <- vapply(ea.methods, 
                function(m) cor(de, sig.sets[,m], use="complete.obs"), 
                numeric(1))
    o <- order(cors, decreasing=TRUE)
    df <- reshape2::melt(sig.sets)
    colnames(df) <- c("Dataset", "Method", "value")
    df$xvalue <- de[as.vector(df$Dataset)] 
    df$Method <- substring(df$Method, 1, 7)
    df$Method <- factor(df$Method, 
        levels=substring(colnames(sig.sets)[o],1,7))
    col <- rev(get_palette(palette = "simpsons", 10))
    ggline(df, x = "xvalue", y = "value", numeric.x.axis = TRUE, 
        linetype = "Method", color="Method",
        palette = "simpsons", ylab="% significant sets", xlab="% DE genes")
}
plotCorDE(ma.de, ma.go.sig.sets)
```

```{r corDE2}
cor.facetplot <- function(de, kegg.sig.sets, go.sig.sets)
{
    cors <- vapply(ea.methods, 
                function(m) cor(de, kegg.sig.sets[,m], use="complete.obs"), 
                numeric(1))
    o <- order(cors, decreasing=TRUE)

    l <- list(KEGG=kegg.sig.sets, GO=go.sig.sets)
    df <- reshape2::melt(l)
    colnames(df)[c(1:2,4)] <- c("dataset", "method", "gsc")
    df$xvalue <- de[as.vector(df$dataset)] 
    df$method <- substring(df$method, 1, 7)
    df$method <- factor(df$method, 
        levels=substring(colnames(kegg.sig.sets)[o],1,7))
    col <- rev(get_palette(palette = "simpsons", 10))
    p <- ggline(df, x = "xvalue", y = "value", numeric.x.axis = TRUE, 
        linetype = "method", color="method",
        palette = "simpsons", ylab="% significant sets", xlab="% DE genes")
    p <- facet(p, facet.by="gsc")     
    return(p)
}
cor.facetplot(ma.de, ma.kegg.sig.sets, ma.go.sig.sets)
cor.facetplot(rseq.de, rseq.kegg.sig.sets, rseq.go.sig.sets)
```

### Type I error rate

```{r golub-dir}
kegg.dir <- file.path(golub.dir, "kegg")
go.dir <- file.path(golub.dir, "go")
```

```{r golub-evalTyI, eval=FALSE}
tyI <- evalTypeIError("globaltest", se, gs=kegg.gs, alpha=0.05, nperm=1000)
```

```{r globalt-golubFDR}
golgt.file <- file.path(kegg.dir, "globaltest.rds")
tyI.globaltest <- readRDS(golgt.file)
tyI.globaltest
tyI.samgs <- readRDS(sub("globaltest", "samgs", golgt.file))
tyI.samgs
```

Using nominal DE p-values for ORA and EBM.

```{r golub-evalTyIMulti, eval=FALSE}
res <- evalTypeIError(ea.methods, se, gs=kegg.gs, save2file=TRUE)
```

```{r evalTyI-results}
readTyI <- function(res.dir)
{
    res.files <- file.path(res.dir, paste0(c(sbeaMethods()[1:10],"camera_igcNA"), ".rds"))
    res.files <- res.files[file.exists(res.files)]
    res <- sapply(res.files, readRDS)
    colnames(res) <- basename(colnames(res))
    colnames(res) <- sub(".rds$", "", colnames(res))
    return(res)
}
kegg.res <- readTyI(kegg.dir)
colnames(kegg.res)[11] <- sub("_igcNA$", "*", colnames(kegg.res)[11])
go.res <- readTyI(go.dir)
colnames(go.res)[11] <- sub("_igcNA$", "*", colnames(go.res)[11])
GSEABenchmarkeR:::plotTypeIError(kegg.res)
GSEABenchmarkeR:::plotTypeIError(go.res)
```

```{r evalTyI-results2}
plotTypeIError2 <- function(data, ylabel=0.4)
{
    data <- t(data)
    rownames(data) <- substring(rownames(data), 1, 7)
    data <- data[order(data[,"Max."] - data[,"Mean"]),]
    df <- data.frame(methods=rownames(data), data)
    colnames(df)[2:7] <- c("y0", "y25", "y50", "mean", "y75", "y100") 
    df[,1] <- factor(df[,1], levels=df[,1])
    df.points <- data.frame(x=1:11, y=df$mean)
    p <- ggplot() + 
        geom_boxplot(data=df, width = 0.8,
            aes(x=df[,1], ymin=y0, lower=y25, middle=y50, upper=y75, ymax=y100), 
            stat="identity", fill="grey92") + theme_pubr()
    #get_palette(palette = "simpsons", 10)
    p <- ggpar(p, x.text.angle=45, legend="none") + xlab("") + ylab("type I error rate") +
    geom_point(data=df.points, aes(x=x, y=y), color=cb.blue) +
    geom_hline(yintercept=0.05, linetype="dashed", color = cb.red) + 
    geom_vline(xintercept=7.5, linetype="dashed", color = cb.darkgrey) +
    geom_label(aes(x=4, y=ylabel), label="competitive", color = cb.darkgrey) +
    geom_label(aes(x=9.5, y=ylabel), label="self-contained", color = cb.darkgrey) 
    return(p)
}
plotTypeIError2(kegg.res, ylabel=0.8) 
plotTypeIError2(go.res) 
```

### Type I error rate: random gene sets of increasing size with shuffled sample labels

TODO: recompute for ORA and EBM

```{r rand-dir2}
random.dir <- file.path(golub.dir, "randomGS", "shuffled_labels")
ea.random.typeI <- readResults(random.dir, gs.grid, 
                                methods=ea.methods, type="typeI")
ea.random.typeI
```

```{r rand-plot}
mean.mat <- vapply(ea.random.typeI, function(x) x["Mean",], numeric(7))
med.mat <- vapply(ea.random.typeI, function(x) x["Median",], numeric(7))
GSEABenchmarkeR:::plotGSSizeRobustness(mean.mat, what="typeI")
GSEABenchmarkeR:::plotGSSizeRobustness(med.mat, what="typeI")
```

### Conclusion

- Nominal *p*-values:
    Three groups:
    1. 5-10% sig sets: camera, gsea, padog, gsa, safe, ora
    2. 25% sig sets: roast, gsva
    3. \>90%: globaltest, samgs (show a clear gene set size dependency)

- Adjusted *p*-values: flattens out signal for most methods, independent of
    gene set DB (GO/KEGG), number of permutations, and whether a built-in 
    correction is used; recommendable for `roast` and `gsva`; does not make a 
    difference for `globaltest` and `samgs`

- Type I error rate:
    1. Inflated type I error rates for `camera` (real gene sets) and `gsa` (real
        and random gene sets)
    2. Many methods show deflated median type I error rates with increasing gene
         set size 
    3. `globaltest` and `samgs` accurately control the type I 
        error rate, yet their sensitive null hypothesis (self-contained) seems 
        to render them of limited practical relevance 

From the `globaltest` vignette (which is a top 5% Bioc package):

Still, it is true that the null hypotheses that the global test tests is false 
even if only a single gene in the gene set is associated with the phenotype; 
especially smaller gene sets may therefore become significant as a result of 
only a single significant gene.  
However, because the test is directed especially against the alternative that 
there are many associated genes, such examples are **rare** among larger gene sets.

Rare = \>90% ??


## Phenotype relevance
### MalaCards disease relevance rankings
```{r malaRankings}
data.dir <- system.file("extdata", package="GSEABenchmarkeR")
mala.kegg.file <- file.path(data.dir, "malacards", "KEGG.rds")
mala.go.file <- file.path(data.dir, "malacards", "GO_BP.rds")
mala.kegg <- readRDS(mala.kegg.file)
mala.go <- readRDS(mala.go.file)
vapply(mala.kegg, nrow, integer(1))
mala.kegg$ALZ
mala.kegg$BRCA
```

### Mapping between dataset ID and disease code
```{r data2dis}
d2d.file <- file.path(data.dir, "malacards", "GseId2Disease.txt")
d2d.map <- readDataId2diseaseCodeMap(d2d.file)
head(d2d.map)
d2d.tcga <- rseq.ids
names(d2d.tcga) <- rseq.ids
```

### Relevance score of a gene set ranking
```{r evalRelevance}
ma.kegg.ranks$ora$GSE1297
obs.score <- evalRelevance(ma.kegg.ranks$ora$GSE1297, mala.kegg$ALZ)
obs.score
```

### Theoretical optimum
```{r compOpt}
gs.names <- ma.kegg.ranks$ora$GSE1297$GENE.SET
gs.ids <- substring(gs.names, 1, 8)
opt.score <- compOpt(mala.kegg$ALZ, gs.ids)
opt.score
round(obs.score / opt.score * 100, digits=2)
```

### Random relevance score distribution
```{r compRand}
rand.scores <- compRand(mala.kegg$ALZ, gs.ids, perm=50)
summary(rand.scores)
(sum(rand.scores >= obs.score) + 1) / 51
```

### Cross-dataset relevance score distribution
```{r evalAll, fig.width=6, fig.height=6}
ma.kegg.rel.sets <- evalRelevance(ma.kegg.ranks, mala.kegg, d2d.map)
ma.go.rel.sets <- evalRelevance(ma.go.ranks, mala.go, d2d.map)
bpPlot(ma.kegg.rel.sets, what="rel.sets")
rseq.kegg.rel.sets <- evalRelevance(rseq.kegg.ranks, mala.kegg, d2d.tcga)
rseq.go.rel.sets <- evalRelevance(rseq.go.ranks, mala.go, d2d.tcga)
facetplot(ma.kegg.rel.sets, ma.go.rel.sets, rseq.kegg.rel.sets, 
    rseq.go.rel.sets, ylab="% optimal relevance score", vline=4.5)
```

competitive vs. self-contained

```{relTests}
sc.methods <- c("samgs", "globaltest", "gsva", "roast")
comp.methods <- c("ora", "gsea", "safe", "gsa", "padog", "camera")
# per compendium + gsc
wilcox.test( as.vector(ma.kegg.rel.sets[,sc.methods]), 
        as.vector(ma.kegg.rel.sets[,comp.methods]))
wilcox.test( as.vector(ma.go.rel.sets[,sc.methods]), 
        as.vector(ma.go.rel.sets[,comp.methods]))
wilcox.test( as.vector(rseq.kegg.rel.sets[,sc.methods]), 
        as.vector(rseq.kegg.rel.sets[,comp.methods]))
wilcox.test( as.vector(rseq.go.rel.sets[,sc.methods]), 
        as.vector(rseq.go.rel.sets[,comp.methods]))
# overall:
wilcox.test(
        c(  as.vector(ma.kegg.rel.sets[,sc.methods]),
            as.vector(ma.go.rel.sets[,sc.methods]),
            as.vector(rseq.kegg.rel.sets[,sc.methods]),
            as.vector(rseq.go.rel.sets[,sc.methods])
        ),
        c(  as.vector(ma.kegg.rel.sets[,comp.methods]),
            as.vector(ma.go.rel.sets[,comp.methods]),
            as.vector(rseq.kegg.rel.sets[,comp.methods]),
            as.vector(rseq.go.rel.sets[,comp.methods])
        )
)
```

```{relMvsM}
testMethods <- function(m1, m2)
{
    suppressWarnings({
    p1 <- wilcox.test( ma.kegg.rel.sets[,m1], ma.kegg.rel.sets[,m2] )$p.value
    p2 <- wilcox.test( ma.go.rel.sets[,m1], ma.go.rel.sets[,m2] )$p.value
    p3 <- wilcox.test( rseq.kegg.rel.sets[,m1], rseq.kegg.rel.sets[,m2] )$p.value
    p4 <- wilcox.test( rseq.go.rel.sets[,m1], rseq.go.rel.sets[,m2] )$p.value
    p5 <- wilcox.test(
        c(  as.vector(ma.kegg.rel.sets[,m1]),
            as.vector(ma.go.rel.sets[,m1]),
            as.vector(rseq.kegg.rel.sets[,m1]),
            as.vector(rseq.go.rel.sets[,m1])
        ),
        c(  as.vector(ma.kegg.rel.sets[,m2]),
            as.vector(ma.go.rel.sets[,m2]),
            as.vector(rseq.kegg.rel.sets[,m2]),
            as.vector(rseq.go.rel.sets[,m2])
        )
    )$p.value
    })
    return(c(ma.kegg=p1,ma.go=p2,rseq.kegg=p3,rseq.go=p4,overall=p5))
}
vapply(setdiff(ea.methods, "padog"), 
        function(m) testMethods("padog", m), 
        numeric(5))
```

```{r relTop20, fig.width=6, fig.height=6}
nsets <- function(ranks, fract=0.2)
{
    ns <- vapply(ranks, nrow, numeric(1))
    ns <- round(fract * mean(ns))
    return(ns)
}

ma.kegg.rel.sets.t20 <- evalRelevance(ma.kegg.ranks, 
    mala.kegg, d2d, top=nsets(ma.kegg.ranks$ora))
ma.go.rel.sets.t20 <- evalRelevance(ma.go.ranks, 
    mala.go, d2d, top=nsets(ma.go.ranks$ora))
rseq.kegg.rel.sets.t20 <- evalRelevance(rseq.kegg.ranks, 
    mala.kegg, d2d.tcga, top=nsets(rseq.kegg.ranks))
rseq.go.rel.sets.t20 <- evalRelevance(rseq.go.ranks, 
    mala.go, d2d.tcga, top=nsets(rseq.go.ranks))
facetplot(ma.kegg.rel.sets.t20, ma.go.rel.sets.t20, rseq.kegg.rel.sets.t20, 
    rseq.go.rel.sets.t20, ylab="% optimal relevance score", vline=4.5)
```


